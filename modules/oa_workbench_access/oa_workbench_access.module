<?php
/**
 * @file
 * Code for the Open Atrium Workbench Access module.
 */

/**
 * Implements hook_oa_access_permission().
 */
function oa_workbench_oa_access_permission() {
  $perms = array();
  foreach (workbench_moderation_transitions() as $transition) {
    $from_state = $transition->from_name;
    $to_state = $transition->to_name;

    $perms["moderate content from $from_state to $to_state"] = array(
      'title' => t('Moderate all content from %from_state to %to_state', array('%from_state' => workbench_moderation_state_label($from_state), '%to_state' => workbench_moderation_state_label($to_state))),
    );
  }
  return $perms;
}

/**
 * Implements hook_workbench_moderation_states_next_alter().
 */
function oa_workbench_access_workbench_moderation_states_next_alter(&$states, $current_state, $context) {
  $account = $context['account'];
  $node = $context['node'];

  // Remove states that the user doesn't have permission to transition to.
  if ($states && !empty($node->nid)) {
    foreach ($states as $machine_name => $label) {
      if (!oa_workbench_access($node, $current_state, $machine_name, $account)) {
        unset($states[$machine_name]);
      }
    }
  }
}

/**
 * Determines if the user can perform a transition.
 *
 * This is based on the user's membership in an Open Atrium Group or Team in
 * the same way that user_access() is based on a user's membership in a role.
 *
 * @param object $node
 *   The node that we want to perform the transition on.
 * @param string $from_state
 *   The machine name of the state we want to transition from.
 * @param string $to_state
 *   The machine name of the state we want to transition to.
 * @param object|NULL $account
 *   (Optional) A user object representing the user to check. If NULL, it will
 *   check for the currently logged in user.
 *
 * @returns boolean
 *   TRUE if the user has permission to perform the transition;
 *   otherwise FALSE.
 */
function oa_workbench_access($node, $from_state, $to_state, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = $user;
  }

  return oa_access("moderate content from $from_state to $to_state", $node, $account);
}

/**
 * Implements hook_node_delete().
 */
function oa_workbench_access_node_delete($node) {
  db_delete('oa_workbench_access')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_workbench_moderation_state_delete().
 *
 * Note: This depends on the patch from issue #2175891:
 *       https://drupal.org/node/2175891
 */
function oa_workbench_access_workbench_moderation_state_delete($state) {
  db_delete('oa_workbench_access')
    ->condition(db_or()
      ->condition('from_name', $state->name)
      ->condition('to_name', $state->name))
    ->execute();
}

/**
 * Implements hook_workbench_moderation_transition_delete().
 *
 * Note: This depends on the patch from issue #2175891:
 *       https://drupal.org/node/2175891
 */
function oa_workbench_access_workbench_moderation_transition_delete($transition) {
  db_delete('oa_workbench_access')
    ->condition('from_name', $transition->from_name)
    ->condition('to_name', $transition->to_name)
    ->execute();
}
