<?php
/**
 * @file
 * Code for the Open Atrium Workbench Access module.
 */

/**
 * Implements hook_menu().
 */
function oa_workbench_access_menu() {
  $items = array();
  $items['admin/openatrium/oa_workbench_access'] = array(
    'title' => 'Workbench access',
    'description' => 'Configure which Groups can perform which transitions',
    'access arguments' => array('administer oa_workbench_access permissions'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('oa_workbench_access_group_permissions_form'),
    'file' => 'oa_workbench_access.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function oa_workbench_permission() {
  return array(
    'administer oa_workbench_access permissions' => array(
      'title' => t('Administer Open Atrium Workbench Access permissions'),
      'description' => t('Allows users to configure which Groups can perform which transitions.'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function oa_workbench_access_theme() {
  return array(
    'oa_workbench_access_permissions_form' => array(
      'render element' => 'transitions',
      'file' => 'oa_workbench_access.theme.inc',
    ),
  );
}

/**
 * Implements hook_workbench_moderation_states_next_alter().
 */
function oa_workbench_access_workbench_moderation_states_next_alter(&$states, $current_state, $context) {
  $account = $context['account'];

  // Remove states that the user doesn't have permission to transition to.
  if ($states) {
    foreach ($states as $machine_name => $label) {
      if (!oa_workbench_access($current_state, $machine_name, $account)) {
        unset($states[$machine_name]);
      }
    }
  }
}

/**
 * Get a list of this user's Groups and Teams.
 *
 * @param object|NULL $user 
 *   (Optional) The user to get groups for. If NULL, it will find groups for
 *   the currently logged in user.
 *
 * @return array
 *   An associative array keyed by group nid containing associative arrays with
 *   the following keys:
 *   - nid: The group nid.
 *   - type: The node type (ex: oa_group, oa_team).
 */
function oa_workbench_access_user_groups($account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = $user;
  }

  $groups = array();

  // First, get all the users oa_groups.
  $query = db_select('og_membership', 'og');
  $query->innerJoin('node', 'n', 'og.gid = n.nid');
  $query
    ->fields('n', array('nid', 'type'))
    ->condition('og.group_type', 'node')
    ->condition('og.entity_type', 'user')
    ->condition('og.state', OG_STATE_ACTIVE)
    ->condition('n.type', 'oa_group')
    ->condition('og.etid', $account->uid);
  foreach ($query->execute() as $row) {
    $groups[$row->nid] = array(
      'nid'  => $row->nid,
      'type' => $row->type,
    );
  }

  // TODO: Next, get all the users oa_teams.

  return $groups;
}

/**
 * Gets all the transitions that a list of groups can perform.
 *
 * @param array $groups
 *   An array of nids of Groups or Teams.
 * 
 * @return array
 *   An associative array keyed by group nid containing associative arrays
 *   keyed by the transition name with a value of TRUE. For example:
 *   @code
 *   array('27' => array('from_state-to_state' => TRUE))
 *   @endcode
 *   Which signifies that the group with nid 27 can perform the transition from
 *   'from_state' to 'to_state'.
 */
function oa_workbench_access_group_permissions($groups) {
  $cache =& drupal_static(__FUNCTION__, array());

  // First, go through the static cache and any groups we don't have data
  // for to the $missing array.
  $missing = array();
  foreach ($groups as $gid) {
    if (!isset($cache[$gid])) {
      $missing[] = $gid;
    }
  }

  // Next, query any of the missing groups from the database and add them to
  // the static cache.
  if (!empty($missing)) {
    $query = db_select('oa_workbench_access', 'a')
      ->fields('a', array('nid', 'from_name', 'to_name'))
      ->condition('a.nid', $missing, 'IN');
    foreach ($query->execute() as $row) {
      $cache[$row->nid][$row->from_name . '-' . $row->to_name] = TRUE;
    }
  }

  // Finally, add all the necessary permissions from the static cache and
  // return it!
  $return = array();
  foreach ($groups as $gid) {
    $return[$gid] = isset($cache[$gid]) ? $cache[$gid] : array();
  }
  return $return;
}

/**
 * Gets all the transitions that a list of groups can perform.
 *
 * The permissions of all the groups are combined, such that if any group in
 * the list has permission to perform a transition, it will be returned.
 *
 * @param array $groups
 *   An array of nids of Groups or Teams.
 * 
 * @return array
 *   An associative array keyed by the transition name with a value of TRUE.
 *   For example:
 *   @code
 *   array('from_state-to_state' => TRUE)
 *   @endcode
 *   Which signifies that the combined permissions of the given groups can
 *   perform the transition from 'from_state' to 'to_state'.
 */
function oa_workbench_access_group_combined_permissions($groups) {
  $return = array();
  foreach (oa_workbench_access_group_permissions($groups) as $gid => $perms) {
    $return = array_merge($return, $perms);
  }
  return $return;
}

/**
 * Determines if the user can perform a transition.
 *
 * This is based on the user's membership in an Open Atrium Group or Team in
 * the same way that user_access() is based on a user's membership in a role.
 *
 * @param string $from_state
 *   The machine name of the state we want to transition from.
 * @param string $to_state
 *   The machine name of the state we want to transition to.
 * @param object|NULL $account
 *   (Optional) A user object representing the user to check. If NULL, it will
 *   check for the currently logged in user.
 *
 * @returns boolean
 *   TRUE if the user has permission to perform the transition;
 *   otherwise FALSE.
 */
function oa_workbench_access($from_state, $to_state, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = $user;
  }

  // This function is most commonly called with the same $from_state and
  // $account but different $to_state's. So the layout of the static cache
  // is optimized for that case.
  $cache =& drupal_static(__FUNCTION__, array());

  if (!isset($cache[$account->uid])) {
    $groups = array_keys(oa_workbench_access_user_groups($account));
    $perms = oa_workbench_access_group_combined_permissions($groups);
    $cache[$account->uid] = $perms;
  }

  return isset($cache[$account->uid][$from_state . '-' . $to_state]);
}

/**
 * Implements hook_node_delete().
 */
function oa_workbench_access_node_delete($node) {
  db_delete('oa_workbench_access')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_workbench_moderation_state_delete().
 *
 * Note: This depends on the patch from issue #2175891:
 *       https://drupal.org/node/2175891
 */
function oa_workbench_access_workbench_moderation_state_delete($state) {
  db_delete('oa_workbench_access')
    ->condition(db_or()
      ->condition('from_name', $state->name)
      ->condition('to_name', $state->name))
    ->execute();
}

/**
 * Implements hook_workbench_moderation_transition_delete().
 *
 * Note: This depends on the patch from issue #2175891:
 *       https://drupal.org/node/2175891
 */
function oa_workbench_access_workbench_moderation_transition_delete($transition) {
  db_delete('oa_workbench_access')
    ->condition('from_name', $transition->from_name)
    ->condition('to_name', $transition->to_name)
    ->execute();
}
